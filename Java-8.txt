Optional Class:
----------------
In Java, a commonly repeated exception is a NullPointerException. So to avoid NullPointerException, Java people introduced Optional Classes in the Java 8 version.
or
It is used to represent non-null value in java. It is used to avoid NullPointerException and avoid having too many null checks(unnecessary null checks).

Optional Object example:
------------------------
with out Optional class:
public class OptionalDemo {

    public static void main(String[] args) {
        String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
}
If Student class contains more properties, then each and every property we should check before accessing that property weather it is null or not?
----------------------------
with Optional Class:
-----------------------------
public class OptionalDemo {

    public static void main(String[] args) {
        /*String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");*/

        Optional<String> nameOptional = getStudentNameUsingOptional();
        if(nameOptional.isPresent()) {
            System.out.println("Student name length is: " + nameOptional.get().length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
    public static Optional<String> getStudentNameUsingOptional() {

        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        if(studentOptional.isPresent()) {
            //return studentOptional.get().getName();
            return studentOptional.map(Student::getName);
        }
        return Optional.empty(); // will return Optional object with no value // will return NoSuchElementException
    }
}
Q) What is difference between if(obj!= null) vs if(obj.isPresent())?
-> Object will wrapped in the form of Optional and if object not contains any value also we can check with the help of optional class method isPresent() for data.
whereas !=null checking, we are directly checking the object, so if object not contains any value then we will get NullPointerException.

Q) Difference between return null; and return Optional.empty();?
-> return null, null can be accepted by any object like String or Student,
   Optional.empty() method can only return Optional object, by using optional object, we can call optional class methods.
------
Optional object creation -> Optional.of() vs  Optional.ofNullable(--) vs Optional.empty():
---------------------------------------------------------------------------
Optional.ofNullable(--):
if we pass any parameter to ofNullable() then it will return Optional<that Object>, if we are not passing any valid paratmer to ofNullable() method then it will return empty Optional object.
Optional.of():
if we pass any parameter to of() then it will return Optional<that Object>, if we are not passing any valid paratmer to of() method then it will return NullPointerException.
Optional.empty():
It is used to return the empty Optional object.

Eg:
--
ublic class OptionalOfEmptyOfNullable {
    public static void main(String[] args) {

        System.out.println("Optional class ofNullable() with Parameter: "+ofNullableWithParameter().get()); // Rohan
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter()); // Optional.emtpy
        //System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().get()); // NoSuchElementException
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().isPresent()); // false
        System.out.println("==================================");
        System.out.println("Optional class of() with paramter: "+ofwithParameter().get()); // Rohan
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter()); // NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().get()); NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().isPresent()); // NullPointerException
        System.out.println("==================================");
        System.out.println("Optional class empty(): "+empty()); // Optional.empty
        //System.out.println("Optional class empty(): "+empty().get()); //NoSuchElementException
    }
    public static Optional<String> ofNullableWithParameter() {
        Optional<String> optionalOfNullable = Optional.ofNullable("Rohan");
        return optionalOfNullable;
    }
    public static Optional<String> ofNullableWithoutParameter() {
        Optional<String> optionalOfNullablewithNull = Optional.ofNullable(null);
        return optionalOfNullablewithNull;
    }

    public static Optional<String> ofwithParameter() {
        return Optional.of("Rohan");
    }
    public static Optional<String> ofwithoutParameter() {
        return Optional.of(null);
    }
    public static Optional<String> empty() {
        return Optional.empty();
    }
}
----------------------
orElse("") vs orElseGet(()->"") vs orElseThrow(()->new R.E()): -
----------------------
orElse() -> This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return value which we passed in orElse("") parameter.

orElseGet() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the value which we passed in orElseGet(()->"").

orElseThrow() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the Exception which we passed in orElseThrow(()-> new R.E()).

eg:
---
public class OptionalOrElseExample {
    //orElse()
    public static String orElseOptional() {
        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        return studentOptional.map(Student::getName).orElse("default value");
    }
    //orElseGet()
    public static String orElseGetOptional() {
        //Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stuOptional = Optional.ofNullable(null);
        return stuOptional.map(Student::getName).orElseGet(() -> "No data found");
    }
    //orElseThrow()
    public static String orElseThrowOptional() {
        //Optional<Student> stOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stOptional = Optional.ofNullable(null);
        return stOptional.map(Student::getName).orElseThrow(()->new RuntimeException("Invalid inputs"));
    }
    public static void main(String[] args) {
        String name = orElseOptional();
        //System.out.println("orElse with proper Output: "+name);
        System.out.println("orElse with out proper output: "+name);
        System.out.println("-----------------------");
        String name1 = orElseGetOptional();
        System.out.println("orElseGet() with proper output: "+name1);
       // System.out.println("orElseGet() with out proper output: "+name1);
        System.out.println("-----------------------");
        String name2 = orElseThrowOptional();
        System.out.println("orElseThrow() with proper output: "+name2);
    }

}
----------------------------------------------------------------------------
isPresent() vs ifPresent()
isPresent() -> This method will check optional object having data or not?. if optional obj having data then it will return true, else it will return false.
ifPresent() -> This method will take input as Consumer. This method also will check optional obj having data or not. if Optional obj having data then it will perform any other operation like other method call or some other class method call using optional obj value as input through Consumer. if Optional obj not having data then no action taken.
Eg:
public class OptionalPresentExample {
    public static void main(String[] args) {

       Optional<String> optional =  Optional.ofNullable("Hello");
       Optional<String> optionalNull =  Optional.ofNullable(null);
        //isPresent()
        System.out.println("is Optional object having data? "+optional.isPresent()); //true
        System.out.println("is Optional object having data? "+optionalNull.isPresent()); //false
        System.out.println("===============");
        //ifPresent()
        optional.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // output will print
        optionalNull.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // no output
    }
}
--------------------------
map() vs flatMap() vs filter() with respect to Optional Class:-
--------------------------
filter(predicate) -> This method will take predicate as input. This filter method we can apply on Optional object. By using this filter(), we can filter the data from Optional object.
map(Function) -> This method will take Function as input. This map method we can apply on Optional object. By using this map(), we can transform the data from Optional object.
eg:
public class OptionalMapFlatMapFilterExample {
    //filter
    public static void filterOptional() {
        Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        studentOptional.filter(s -> s.getGpa()>8)
                .ifPresent(st-> System.out.println(st));
    }
    //map
    public static void mapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        //stuOptional.map(Student::getName)
        //        .ifPresent(s -> System.out.println(s));
        if(stuOptional.isPresent()) {
            Optional<String> sOptonal = stuOptional.filter(s->s.getGpa()>7)
                    .map(s->s.getName());
            System.out.println(sOptonal.get());
        }
    }
//flatMap
public static void flatMapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<String> bikeName = stuOptional.filter(s->s.getGpa()>9)
                .flatMap(Student::getBike)
                .map(Bike::getName);
        //System.out.println("Bike Name: "+bikeName.get());
        bikeName.ifPresent(s-> System.out.println("Bike name: "+s));
    }
    public static void main(String[] args) {
        filterOptional();
        mapOptional();
	flatMapOptional();
    }
}

=========================================
Default and Static methods in interfaces:
=========================================
Before java8, its very difficult to add new features in interfaces to existing project. Because implementation classes will be effected. So to resolve this issue, Java people intruduced Default and static method in interfaces in java8.
-> Default method having default method. But if developer not satisfied with default implementation, then developer can override the default method in the implementation class.
-> Static method having the implementation. but we can not override the static method in implementation class. but we can declare exact satic method signature in implementation class. but it is not overriding. it is method hiding. advatage with method hiding is, we can stop seeing the developers default static method implementation in interface.
-> Default methods can be overridden but static methods can not be overridden.
eg:
public class DefaultMethodExample {

    public static void main(String[] args) {
        //sort the names in alphabetical order

        List<String> nameList = Arrays.asList("Raja","Amar","Bunny","Sunny");

        //approach - 1 , before java 8
        Collections.sort(nameList);
        System.out.println("Using Collections.sort(): "+nameList);
        System.out.println("-----------------------------");
        //approach - 2, using List default method sort()
        //nameList.sort(Comparator.comparing(Function.identity()));
        //or
        nameList.sort(Comparator.naturalOrder());
        System.out.println(nameList);
        System.out.println("-----------------------------");
        //from java8
       List<String> sortedList = nameList.stream()
                .sorted((i1,i2)->i1.compareTo(i2))
                .collect(Collectors.toList());
        System.out.println(sortedList);
        System.out.println("----------------------");

        //to reverse the order

        nameList.sort(Comparator.reverseOrder());
        System.out.println("reverse order: "+nameList);
    }
}
List interface having default methods called - sort(), retainAll() and spliterator()
------------------------------------------------------------------------------------
Exploring sort() operations using Comparator interface:
-------------------------------------------------------
ex:1:

public class DefaultMethodsEx2 {
    static Consumer<Student> studentConsumer = student -> System.out.println(student);
    static Comparator<Student> gradeComparator = Comparator.comparing(Student::getGradeLevel);
    static Comparator<Student> nameComparator = Comparator.comparing(Student::getName);
    public static void sortByName(List<Student> stuList) {
        System.out.println("After sorting :::::");
        Comparator<Student> studentComparator = Comparator.comparing(Student::getName);
        stuList.sort(studentComparator);
        //stuList.forEach(System.out::println);
        //or
        stuList.forEach(studentConsumer);
    }
    public static void sortByGPA(List<Student> stuList) {
        System.out.println("Sort by GPA ::::");
        //Consumer<Student> stuConsumer = Comparator.comparing((st1,st2)->st1.);
        stuList.sort(Comparator.comparingDouble(Student::getGpa));
        stuList.forEach(studentConsumer);
    }
    public static void comparingComparator(List<Student> stdList) {
        System.out.println(":::::::::: Comparator Comparing :::::::");
        stdList.sort(gradeComparator.thenComparing(nameComparator));
        stdList.forEach(studentConsumer);
    }
    public static void main(String[] args) {
        System.out.println("Before Sorting ::::");
        List<Student> studentList = StudentData.getStudentData();
        //System.out.println(studentList);
        studentList.forEach(studentConsumer);

        sortByName(studentList);
        sortByGPA(studentList);
        comparingComparator(studentList);
    }
}
----------------------------------------------------
Handle null values while sorting using comparator:
----------------------------------------------------
eg:2:
public static void sortWithNullValues(List<Student> stList) {
        System.out.println("Sort with null values");
        Comparator<Student> stComp = Comparator.nullsFirst(nameComparator);
        stList.forEach(studentConsumer);
    }
-> nullsFirst() --> this method will print null values at first.
-> nullsLast() --> this method will print null values at last.
----------------------------------------------------
Create an interface with default and static methods:
----------------------------------------------------
public interface Multiplier {

    int mulitply(List<Integer> intList);

    default int size(List<Integer> iList) {
        System.out.println("Multiplier interface size()");
        return iList.size();
    }
    static boolean isEmpty(List<Integer> intList) {
        return intList==null && intList.size()==0;
    }
}

public class MultiplierImpl implements Multiplier{

    @Override
    public int mulitply(List<Integer> intList) {
        return intList.stream()
                .reduce(1,(a,b)->a*b);
    }
    public int size(List<Integer> iList) {
        System.out.println("MultiplierImpl class size()");
        return iList.size();
    }
}

public class MultiplierClient {

    public static void main(String[] args) {

        Multiplier multiplier = new MultiplierImpl();
        List<Integer> iList = Arrays.asList(1,3,5);
        System.out.println("Multipling result is: "+multiplier.mulitply(iList)); //15
        System.out.println("size is: "+multiplier.size(iList)); //MultiplierImpl class size()

        System.out.println("is the List empty: "+Multiplier.isEmpty(iList)); // false
    }
}
here size() will invoke from MultiplierImpl class because always it invoke from runtime object. 
-----------------------------------------------------------------------------------------------
Abstract class vs interface in java8:
------------------------------------------------------------------------------------------------
-> Abstract classes having instance variables but interfaces does not.
-> Java 8 supports multiple inheritance. ie before java 8, it is not possible. --> need to test weather it is supported or not?
eg:
public interface Interface1 {

    default void methodA() {
        System.out.println("Inside Method A "+Interface1.class);
    }
}
public interface Interface2 extends Interface1{
    default void methodB() {
        System.out.println("Inside Method B "+Interface2.class);
    }
    default void methodA() {
        System.out.println("Inside Method A "+Interface2.class);
    }
}
public interface Interface3 extends Interface2{
    default void methodC() {
        System.out.println("Inside Method C "+Interface3.class);
    }
}
public class Client123 implements Interface1,Interface2,Interface3{

   /* public void methodA() {
        System.out.println("Inside Method A "+Interface1.class);
    }*/
    public static void main(String[] args) {

        Client123 c = new Client123();
        c.methodA(); // result will print from child interface class Interface2. At runtime always will print child class methods in overridding.
        c.methodB();
        c.methodC();
    }
}
Note: Here we are inheriting multiple behaviours from multiple interfaces. This is called multiple inheritance.
-----------------------------------
Multiple inheritance issues resolve"
-----------------------------------
When ever we are implementing interfaces and that interfaces having same method with signature. then java will confuse. so to resolve that cases, we have to  override that method in our implementation class.
Eg:
public interface Interface1 {

    default void methodA(){
        System.out.println("Method A from "+Interface1.class);
    }
}
public interface Interface4 {

    default void methodA(){
        System.out.println("Method A from "+Interface4.class);
    }
}
public class Client14 implements Interface1,Interface4{

    public void methodA(){
        System.out.println("Method A from "+Client14.class);
    }

    public static void main(String[] args) {

        Client14 c14 = new Client14();
        c14.methodA(); //Method A from class org.learn.java8.defaults.Client14
    }
}
========================================================================================================================================================
New Date/Time APIs
========================================================================================================================================================
LocalDate, LocalTime and LocalDateTime class introduced in Java 8 as part of java.time pacakge. - new classes are created with the inspiration of Joda-Time library.
--> Present in java.time package
--> All these new libraries are immutable to promote functional programming.
--> Supproting class like Instant, Duration, Period and etc.
--> LocalDate: Used to represent the date.
--> LocalDate: Used to represent the time.
--> LocalDateTime: Used to represent the Data and time.
Eg: 
public class NewDataTimeExample {
    public static void main(String[] args) {
        //LocalDate
        LocalDate localDate = LocalDate.now();
        //LocalTime
        LocalTime localTime = LocalTime.now();
        //LocalDateTime
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("Local Date: "+localDate); // Local Date: 2024-04-08
        System.out.println("Local Time: "+localTime); // Local Time: 13:34:25.722924100
        System.out.println("Local Date and Time: "+localDateTime); // Local Date and Time: 2024-04-08T13:34:25.722924100
    }
Note: now() is overloaded method. i.e.
now()
now(Clock clock)
now(ZoneId zone)
--------------------------------------------------------------
LocalDate class Example:
-------------------------------------------
public class LocalDateExample {
    public static void main(String[] args) {

        LocalDate localDate = LocalDate.now();
        System.out.println(localDate); //2024-04-08
        LocalDate localDate2 = LocalDate.of(2024,06,14);
        System.out.println(localDate2);
        LocalDate localDate3 = LocalDate.ofYearDay(2022,360);
        System.out.println(localDate3);
        /*Get values from LocalDate*/
        System.out.println("getMonth(): "+localDate.getMonth()); // APRIL
        System.out.println("getMonthValue(): "+localDate.getMonthValue()); // 4
        System.out.println("getDayOfMonth(): "+localDate.getDayOfMonth()); // 8
        System.out.println("getDayOfWeek(): "+localDate.getDayOfWeek()); // MONDAY
        System.out.println("getDayOfYear(): "+localDate.getDayOfYear()); //99
        System.out.println("Day of month using get(): "+localDate.get(ChronoField.DAY_OF_MONTH)); // 8
    }
}
Note: get() method will take input as TemporalField interface as input. So ChronoField is an enum to implement TemporalField interface. So ChronoField enum having lot of constants to get the Date details.
-------------------------------------------------------------------------------------------
LocalDate - Modify LocalDate object values:
------------------------------------------------------------------------------
/*Modifying LocalDate object values*/
        System.out.println("Increase Date value by 2: "+localDate.plusDays(2)); // 2024-04-10
        System.out.println("Increase Month value by 2: "+localDate.plusMonths(2)); // 2024-06-08
        System.out.println("Decrease Month value by 3: "+localDate.minusMonths(3)); // 2024-01-08
        System.out.println("To change the Year to 2022: "+localDate.withYear(2022)); // 2022-04-08

        System.out.println("Change year with ChronoField: "+localDate.with(ChronoField.YEAR,2020)); // 2020-04-08
        System.out.println("First day of next month using with method TemporalAdjusters: "+localDate.with(TemporalAdjusters.firstDayOfMonth())); // 2024-04-01
	System.out.println("Change year with ChronoUnit: "+localDate.minus(1, ChronoUnit.YEARS)); // 2023-04-08
---------------------------------

/*Additional Support methods*/

System.out.println("2024 is leap year or not? "+localDate.isLeapYear()); // true
        //or
        System.out.println("is Leap year? "+LocalDate.ofYearDay(2021,30).isLeapYear()); // false
        //localDate = 2024-04-08
        //localDate1 = 2024-06-14
        System.out.println("is equal? "+localDate.isEqual(localDate1)); // false
        System.out.println("is before? "+localDate.isBefore(localDate1)); // true
        System.out.println("is after? "+localDate.isAfter(localDate1)); // false

        /*Unsupported*/
       // System.out.println("subtract minutes: "+localDate.minus(2,ChronoUnit.MINUTES)); // R.E: UnsupportedTemporalTypeException
        // We can not subtract minutes from LocalDate.

        System.out.println("is supported: "+localDate.isSupported(ChronoUnit.MINUTES)); // false
	System.out.println("is supported? : "+localDate.isSupported(ChronoUnit.YEARS)); // true
------------------------------------------------------------------------------
LocalTime:
---------------------------------------------------------------------------
public class LocalTimeExample {
    public static void main(String[] args) {
        LocalTime localTime = LocalTime.now();
        System.out.println("LocalTime: "+localTime);
        LocalTime localTime1 = LocalTime.of(18,45);
        System.out.println("localTime.of(hours,minutes): "+localTime1);
        LocalTime localtime2 = LocalTime.of(10,30,45);
        System.out.println("localTime.of(hours,minutes,sec) "+localtime2);
        LocalTime localtime3 = LocalTime.of(21,35,10,485);
        System.out.println("LocalTime.of(H,M,S,NS)"+localtime3);

        /*Getting time details from LocalTime object*/

        System.out.println("getHours(): "+localTime.getHour()); //17
        System.out.println("getMinutes(): "+localTime.getMinute()); // 53
        System.out.println("getHours() using ChronoField: "+localTime.get(ChronoField.CLOCK_HOUR_OF_DAY)); // 17
        System.out.println("getSeconds() using ChronoField: "+localTime.get(ChronoField.MINUTE_OF_DAY)); //1074
        System.out.println("getSeconds(): "+localTime.getSecond()); //43
        System.out.println("toSecondsOfDay(): "+localTime.toSecondOfDay()); // 64607 // represents whole time in Seconds for the day.

        /*Modify values in localtime object*/
        System.out.println("minus hours: "+ localTime.minusHours(3));
        System.out.println("minus hours: "+localTime.minus(3, ChronoUnit.HOURS));
        System.out.println("midnight: "+ localTime.with(LocalTime.MIDNIGHT));
        System.out.println("change hours: "+localTime.with(ChronoField.HOUR_OF_DAY,5)); // HOURS ALWAYS 5
        System.out.println("plus minutes: "+localTime.plusMinutes(5));
        System.out.println("withhour(): "+localTime.withHour(13)); // always hours are 13
    }
}
---------------------------------------------------------------------
LocalDateTime class: 
---------------------------------------------------------------------
of() is factory method

eg:
public class LocalDateTimeExample {
    public static void main(String[] args) {

        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("LocalDateTime: "+localDateTime); // 2024-04-11T12:00:58.432252800

        LocalDateTime ldt = LocalDateTime.of(LocalDate.now(), LocalTime.now());
        System.out.println("LocalDateTime.of() "+ldt); // 2024-04-11T12:00:58.432252800
        LocalDateTime ldt1 = LocalDateTime.of(2024,02,23,13,55,20,958);
        System.out.println("LocalDateTime.of(): "+ldt1); // 2024-02-23T13:55:20.000000958
        //getting date and time from LocalDateTime instance
        System.out.println("getting hours: "+localDateTime.getHour()); // 13
        System.out.println("getting minutes: "+localDateTime.getMinute()); // 11
        System.out.println("getting day: "+localDateTime.getDayOfMonth()); //15
        System.out.println("getting day: "+localDateTime.getDayOfWeek()); // MONDAY
        System.out.println("getting day: "+localDateTime.getDayOfYear()); // 106
        System.out.println("getting day using another way: "+localDateTime.get(ChronoField.DAY_OF_MONTH)); // 15
        //modifying LocalDateTime
        System.out.println("Plus Hours: "+localDateTime.plusHours(3));
        System.out.println("Minus Days: "+localDateTime.minusDays(5));
        //with() method is very useful to modify the LocalDateTime

        System.out.println("Change minutes: "+localDateTime.withMinute(10)); // minutes always 10
        System.out.println("Change month: "+localDateTime.withMonth(1)); // month always 1
        

    }
}
------------------------------
Converting LocalDate / LocalTime to LocalDateTime and viceversa
------------------------------
eg:
LocalDate localDate = LocalDate.of(2020,12,30);
        System.out.println("atTime(): "+localDate.atTime(16,55)); // 2020-12-30T16:55 // atTime() will return LocalDateTime class with given time.
        LocalTime localTime = LocalTime.of(18,25,10);
        System.out.println("atDate(): "+localTime.atDate(LocalDate.of(2021,10,25))); // 2021-10-25T18:25:10 // atDate() will return LocalDateTime class with given date.
        //getting LocalDate and LocalTime from LocalDateTime instance

        LocalDateTime ldt2 = localTime.atDate(LocalDate.of(2022,10,30));
        System.out.println("toLocalDate: "+ldt2.toLocalDate()); // 2022-10-30
        System.out.println("toLocalTime: "+ldt2.toLocalTime()); // 18:25:10
--------------------------------------------------------------------------------------
Comparing Dates using Period class:
--------------------------------------------------------------------------------------
-> Period is a date-based representation of time in Days, Months and Years and is part of the java.time package

-> Compatible with LocalDate.

-> It represents a Period of Time not just a specific date and time.
example:
-> Period period1 = Period.ofDays(10); // represents a Period of 10 Days. ofDays() method is factory method.
-> Period period2 = Period.ofYears(20); // represents a period of 20 years.

Period: use-case:
-----------------
-> Mainly used to calculate the difference between the two dates.
LocalDate localDate1 = LocalDate.of(2018,01,01);
LocalDate localDate2 = LocalDate.of(2018,01,31);
Period period = Period.between(localDate1,localDate2); // caluclates the difference between the two dates.
**** Period is compatible with LocalDate only.
-> Period class does not contain any LocalTime related methods.
eg:
public class ComparingDatesPeriodEx {
    public static void main(String[] args) {

        LocalDate localDate1 = LocalDate.of(2018,01,01);
        LocalDate localDate2 = LocalDate.of(2018,8,28);

        //Period period =  Period.between(localDate1,localDate2);
        Period period = localDate1.until(localDate2);
        /*until() method is part of LocalDate class.  until() will return Period as return type.*/
        //System.out.println(period); // P1M27D
        System.out.println("get Days: "+period.getDays()); // 27 // result is 28-1
        System.out.println("get months: "+period.getMonths()); // 7 // result is 8-1
        System.out.println("get years: "+period.getYears()); // 0 // 2018-2018

        // Creating period instance using of...() factory method
        Period period1 = Period.ofDays(10);
        System.out.println("period1.getDays(): "+period1.getDays());
        Period period2 = Period.ofMonths(22);
        System.out.println("period2.getMonths(): "+period2.getMonths());
        Period period3 = Period.ofYears(10);
        System.out.println("period3.getYears(): "+period3.getYears());
        Period period4 = Period.ofWeeks(35);
        System.out.println("period4.getWeeks(): "+period4.getDays()); // 245

        System.out.println("period3.getMonths(): "+period3.getMonths()); // 0 // this is not right ways to find total months
        System.out.println("period3.toTotalMonths(): "+period3.toTotalMonths()); // 120
        /*by using Period class also we can compare dates using between(). i.e. Period.between(...)*/

        Period period5 = Period.between(localDate1,localDate2);
        System.out.println("Period: "+period5.getDays()+":"+period5.getMonths()+":"+period5.getYears());
        //*** Period.between() is compatible with LocalDate only. it will not accept LocalTime
        //Period.between(LocalTime.now(),LocalTime.now().plusHours(24)); // will not accept
    }
}
-------------------------------------
Duration:
-------------------------------------
-> A time based representation of time in hours, minutes, seconds and nanoseconds.
-> Compatible with LocalTime and LocalDateTime.
-> Duration class does not contain any LocalDate related methods.
-> It represents duration of time not just a specific time.
eg:
Duration hours = Duration.ofHours(3); // it represents the duration of 3 hours.
Duration minutes = Duration.ofMinutes(3); // it represents the duration of 3 minutes.

Duration: Use-case
------------------
It can be used to calculate the difference between the time objects such as LocalTime and LocalDateTime..
Eg:
LocalTime localTime1 = LocalTime.of(7,20);
LocalTime localTime2 = LocalTime.of(8,20);
Duration duration = Duration.between(localTime1,localTime2);
Eg:
public class ComparingTimeDurationEx {
    public static void main(String[] args) {
        LocalTime localTime1 = LocalTime.of(7,20);
        LocalTime localTime2 = LocalTime.of(8,20);
        Duration duration = Duration.between(localTime1,localTime2);
        System.out.println("duration.toMinutes(): "+duration.toMinutes()); // PT1H
        //until() is taking 2 parameters, 1 is second localTime instance and 2nd parameter is to represent the output in which format
        long diff = localTime1.until(localTime2, ChronoUnit.MINUTES);
        System.out.println("localTime.until(): "+diff); // 60
        Duration duration1 = Duration.ofHours(3);
        System.out.println("duration1.toMinutes(): "+duration1.toMinutes());
        //let's try to pass date info to Duration class. let's see what will happen
        LocalDate localDate1 = LocalDate.now();
        LocalDate localDate2 = LocalDate.now().plusDays(5);
        //Duration duration2 = Duration.between(localDate1,localDate2); // R.E: UnsupportedTemporalTypeException
        
    }
}

***********
Finally: If we have a use-case like time related logic like find the difference between 2 times then use Duration. If Date related comparisions then use Period class. 

-------------------------------------------------------------------------
Instant:
------------------------------------------------------------------------
--> The above class like Duration or Period are represent in human readable format.
--> Instant represents the time in machine readable format.
eg:
Instant ins = Instant.now();
--> Represents the time in seconds from January 01,1970(EPOCH) to current time as a huge number.

eg:
public class InstantEx {
    public static void main(String[] args) {
        Instant ins = Instant.now();
        System.out.println("Instant: "+ins); // 2024-04-16T07:51:53.714039600Z // it will print in human-readable format.
        //getEpochSecond() method will print the time in seconds from 01 Jan 1970 to till date in seconds. each day seconds is 86400
        System.out.println(ins.getEpochSecond()); //1713254150
        System.out.println(Instant.ofEpochSecond(0)); // 1970-01-01T00:00:00Z
        Instant ins1 = Instant.now();
        Duration diff = Duration.between(ins,ins1);
        System.out.println("diff: "+diff.getNano()); // 10028700
    }
}
-----------------------------------------------
Time Zones:
-----------------------------------------------
-> LocalDate, LocalTime or LocalDateTime classes are for Local Time Zone represents.
-> Java8 introduced time zones classes to represents worldwide times.
-> ZonedDateTime,ZoneID, ZoneOffset etc.
--> ZonedDateTime - Represents the date/time with its time zone.
	eg:
	2018-07-18T08:04:14.541+05:30[Asia/Calcutta]
--> ZoneOffset -> +05:30
	--> it represents offset time from the UDC time.
--> ZoneId -> [Asia/Calcutta]
	--> it represents the zone that time belongs too.





































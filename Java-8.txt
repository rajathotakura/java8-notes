Optional Class:
----------------
In Java, a commonly repeated exception is a NullPointerException. So to avoid NullPointerException, Java people introduced Optional Classes in the Java 8 version.
or
It is used to represent non-null value in java. It is used to avoid NullPointerException and avoid having too many null checks(unnecessary null checks).

Optional Object example:
------------------------
with out Optional class:
public class OptionalDemo {

    public static void main(String[] args) {
        String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
}
If Student class contains more properties, then each and every property we should check before accessing that property weather it is null or not?
----------------------------
with Optional Class:
-----------------------------
public class OptionalDemo {

    public static void main(String[] args) {
        /*String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");*/

        Optional<String> nameOptional = getStudentNameUsingOptional();
        if(nameOptional.isPresent()) {
            System.out.println("Student name length is: " + nameOptional.get().length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
    public static Optional<String> getStudentNameUsingOptional() {

        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        if(studentOptional.isPresent()) {
            //return studentOptional.get().getName();
            return studentOptional.map(Student::getName);
        }
        return Optional.empty(); // will return Optional object with no value // will return NoSuchElementException
    }
}
Q) What is difference between if(obj!= null) vs if(obj.isPresent())?
-> Object will wrapped in the form of Optional and if object not contains any value also we can check with the help of optional class method isPresent() for data.
whereas !=null checking, we are directly checking the object, so if object not contains any value then we will get NullPointerException.

Q) Difference between return null; and return Optional.empty();?
-> return null, null can be accepted by any object like String or Student,
   Optional.empty() method can only return Optional object, by using optional object, we can call optional class methods.
------
Optional object creation -> Optional.of() vs  Optional.ofNullable(--) vs Optional.empty():
---------------------------------------------------------------------------
Optional.ofNullable(--):
if we pass any parameter to ofNullable() then it will return Optional<that Object>, if we are not passing any valid paratmer to ofNullable() method then it will return empty Optional object.
Optional.of():
if we pass any parameter to of() then it will return Optional<that Object>, if we are not passing any valid paratmer to of() method then it will return NullPointerException.
Optional.empty():
It is used to return the empty Optional object.

Eg:
--
ublic class OptionalOfEmptyOfNullable {
    public static void main(String[] args) {

        System.out.println("Optional class ofNullable() with Parameter: "+ofNullableWithParameter().get()); // Rohan
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter()); // Optional.emtpy
        //System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().get()); // NoSuchElementException
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().isPresent()); // false
        System.out.println("==================================");
        System.out.println("Optional class of() with paramter: "+ofwithParameter().get()); // Rohan
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter()); // NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().get()); NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().isPresent()); // NullPointerException
        System.out.println("==================================");
        System.out.println("Optional class empty(): "+empty()); // Optional.empty
        //System.out.println("Optional class empty(): "+empty().get()); //NoSuchElementException
    }
    public static Optional<String> ofNullableWithParameter() {
        Optional<String> optionalOfNullable = Optional.ofNullable("Rohan");
        return optionalOfNullable;
    }
    public static Optional<String> ofNullableWithoutParameter() {
        Optional<String> optionalOfNullablewithNull = Optional.ofNullable(null);
        return optionalOfNullablewithNull;
    }

    public static Optional<String> ofwithParameter() {
        return Optional.of("Rohan");
    }
    public static Optional<String> ofwithoutParameter() {
        return Optional.of(null);
    }
    public static Optional<String> empty() {
        return Optional.empty();
    }
}
----------------------
orElse("") vs orElseGet(()->"") vs orElseThrow(()->new R.E()): -
----------------------
orElse() -> This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return value which we passed in orElse("") parameter.

orElseGet() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the value which we passed in orElseGet(()->"").

orElseThrow() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the Exception which we passed in orElseThrow(()-> new R.E()).

eg:
---
public class OptionalOrElseExample {
    //orElse()
    public static String orElseOptional() {
        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        return studentOptional.map(Student::getName).orElse("default value");
    }
    //orElseGet()
    public static String orElseGetOptional() {
        //Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stuOptional = Optional.ofNullable(null);
        return stuOptional.map(Student::getName).orElseGet(() -> "No data found");
    }
    //orElseThrow()
    public static String orElseThrowOptional() {
        //Optional<Student> stOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stOptional = Optional.ofNullable(null);
        return stOptional.map(Student::getName).orElseThrow(()->new RuntimeException("Invalid inputs"));
    }
    public static void main(String[] args) {
        String name = orElseOptional();
        //System.out.println("orElse with proper Output: "+name);
        System.out.println("orElse with out proper output: "+name);
        System.out.println("-----------------------");
        String name1 = orElseGetOptional();
        System.out.println("orElseGet() with proper output: "+name1);
       // System.out.println("orElseGet() with out proper output: "+name1);
        System.out.println("-----------------------");
        String name2 = orElseThrowOptional();
        System.out.println("orElseThrow() with proper output: "+name2);
    }

}
----------------------------------------------------------------------------
isPresent() vs ifPresent()
isPresent() -> This method will check optional object having data or not?. if optional obj having data then it will return true, else it will return false.
ifPresent() -> This method will take input as Consumer. This method also will check optional obj having data or not. if Optional obj having data then it will perform any other operation like other method call or some other class method call using optional obj value as input through Consumer. if Optional obj not having data then no action taken.
Eg:
public class OptionalPresentExample {
    public static void main(String[] args) {

       Optional<String> optional =  Optional.ofNullable("Hello");
       Optional<String> optionalNull =  Optional.ofNullable(null);
        //isPresent()
        System.out.println("is Optional object having data? "+optional.isPresent()); //true
        System.out.println("is Optional object having data? "+optionalNull.isPresent()); //false
        System.out.println("===============");
        //ifPresent()
        optional.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // output will print
        optionalNull.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // no output
    }
}
--------------------------
map() vs flatMap() vs filter() with respect to Optional Class:-
--------------------------
filter(predicate) -> This method will take predicate as input. This filter method we can apply on Optional object. By using this filter(), we can filter the data from Optional object.
map(Function) -> This method will take Function as input. This map method we can apply on Optional object. By using this map(), we can transform the data from Optional object.
eg:
public class OptionalMapFlatMapFilterExample {
    //filter
    public static void filterOptional() {
        Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        studentOptional.filter(s -> s.getGpa()>8)
                .ifPresent(st-> System.out.println(st));
    }
    //map
    public static void mapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        //stuOptional.map(Student::getName)
        //        .ifPresent(s -> System.out.println(s));
        if(stuOptional.isPresent()) {
            Optional<String> sOptonal = stuOptional.filter(s->s.getGpa()>7)
                    .map(s->s.getName());
            System.out.println(sOptonal.get());
        }
    }
//flatMap
public static void flatMapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<String> bikeName = stuOptional.filter(s->s.getGpa()>9)
                .flatMap(Student::getBike)
                .map(Bike::getName);
        //System.out.println("Bike Name: "+bikeName.get());
        bikeName.ifPresent(s-> System.out.println("Bike name: "+s));
    }
    public static void main(String[] args) {
        filterOptional();
        mapOptional();
	flatMapOptional();
    }
}

=========================================
Default and Static methods in interfaces:
=========================================
Before java8, its very difficult to add new features in interfaces to existing project. Because implementation classes will be effected. So to resolve this issue, Java people intruduced Default and static method in interfaces in java8.
-> Default method having default method. But if developer not satisfied with default implementation, then developer can override the default method in the implementation class.
-> Static method having the implementation. but we can not override the static method in implementation class. but we can declare exact satic method signature in implementation class. but it is not overriding. it is method hiding. advatage with method hiding is, we can stop seeing the developers default static method implementation in interface.

eg:
public class DefaultMethodExample {

    public static void main(String[] args) {
        //sort the names in alphabetical order

        List<String> nameList = Arrays.asList("Raja","Amar","Bunny","Sunny");

        //approach - 1 , before java 8
        Collections.sort(nameList);
        System.out.println("Using Collections.sort(): "+nameList);
        System.out.println("-----------------------------");
        //approach - 2, using List default method sort()
        //nameList.sort(Comparator.comparing(Function.identity()));
        //or
        nameList.sort(Comparator.naturalOrder());
        System.out.println(nameList);
        System.out.println("-----------------------------");
        //from java8
       List<String> sortedList = nameList.stream()
                .sorted((i1,i2)->i1.compareTo(i2))
                .collect(Collectors.toList());
        System.out.println(sortedList);
        System.out.println("----------------------");

        //to reverse the order

        nameList.sort(Comparator.reverseOrder());
        System.out.println("reverse order: "+nameList);
    }
}
List interface having default methods called - sort(), retainAll() and spliterator()
------------------------------------------------------------------------------------
Exploring sort() operations using Comparator interface:
-------------------------------------------------------
ex:1:

public class DefaultMethodsEx2 {
    static Consumer<Student> studentConsumer = student -> System.out.println(student);
    static Comparator<Student> gradeComparator = Comparator.comparing(Student::getGradeLevel);
    static Comparator<Student> nameComparator = Comparator.comparing(Student::getName);
    public static void sortByName(List<Student> stuList) {
        System.out.println("After sorting :::::");
        Comparator<Student> studentComparator = Comparator.comparing(Student::getName);
        stuList.sort(studentComparator);
        //stuList.forEach(System.out::println);
        //or
        stuList.forEach(studentConsumer);
    }
    public static void sortByGPA(List<Student> stuList) {
        System.out.println("Sort by GPA ::::");
        //Consumer<Student> stuConsumer = Comparator.comparing((st1,st2)->st1.);
        stuList.sort(Comparator.comparingDouble(Student::getGpa));
        stuList.forEach(studentConsumer);
    }
    public static void comparingComparator(List<Student> stdList) {
        System.out.println(":::::::::: Comparator Comparing :::::::");
        stdList.sort(gradeComparator.thenComparing(nameComparator));
        stdList.forEach(studentConsumer);
    }
    public static void main(String[] args) {
        System.out.println("Before Sorting ::::");
        List<Student> studentList = StudentData.getStudentData();
        //System.out.println(studentList);
        studentList.forEach(studentConsumer);

        sortByName(studentList);
        sortByGPA(studentList);
        comparingComparator(studentList);
    }
}
----------------------------------------------------
Handle null values while sorting using comparator:
----------------------------------------------------
eg:2:
public static void sortWithNullValues(List<Student> stList) {
        System.out.println("Sort with null values");
        Comparator<Student> stComp = Comparator.nullsFirst(nameComparator);
        stList.forEach(studentConsumer);
    }
-> nullsFirst() --> this method will print null values at first.
-> nullsLast() --> this method will print null values at last.
----------------------------------------------------










Why Java 8?
===========
--> Java creators wanted to introduced the Functional features as
	-> Lambdas
	-> Functional Interfaces
	-> Streams
	-> Optional and etc.,
--> Before java 8, we used threads for concurrency. 
--> New java 8 features simplify the concurrency operations.
Functional Programming:
-----------------------
--> Embraces object immutability.
--> More concise and readable code.
--> We can assign a function to variable and that variable we can pass to another method.
	Eg:
	Function<String,String> addSomeString = name->name.toUpperCase().concat("default");
--> We can write code using Declarative approach rather than imperative approach.
Imperative Style vs Declarative Style of programming:
-----------------------------------------------------
Imperative Style:
-----------------------
--> Focus on how to perform the operations.
--> Embrace object mutability. (We can modify the object).
--> This style of programming lists the step by step of instructions on how to achieve an objective.
--> We write the code on what needs to be done in each step.
--> Imperative style is used with classic Object Oriented Programming.
Declarative Style:
------------------
--> Focuses on what is the result you want. it does not bother about how to get the result.
--> Embraces object immutability.
--> Use the functions that are already part of the library to achieve an objective.
--> Functional programming uses the concept of declarative programming.
eg:
public class ImperativeVsDeclarativeEx1 {
    public static void main(String[] args) {
        /*
        * Imperative style of programming
         */
        int sum = 0;
        for(int i=1;i<=100;i++) {
            sum+=i;
        }
        System.out.println("Sum using imperative approach: "+sum);
        /*
        * Declarative style of programming
        */
        int sum1 = IntStream.rangeClosed(0,100)
                .parallel() // if it is multi-threaded environment. then using parallel(), we will get same result with better performace.
                .sum();
        System.out.println("Sum using declarative approach: "+sum1);
    }
}

Eg:2:
-----
public class ImperativeVsDeclarativeEx2 {
    public static void main(String[] args) {
        /*Remove duplicates in List*/
        List<Integer> intList = List.of(4,6,2,4,8,6,7,3);
        List<Integer> intList1 = Arrays.asList(4,6,2,4,8,6,7,3);
        /*Imperative style*/
        List<Integer> uniqList = new ArrayList<>();
        for(Integer i : intList1) {
            if(!uniqList.contains(i)) {
                uniqList.add(i);
            }
        }
        System.out.println("Unique List: "+uniqList);
        /*Declarative style*/
        List<Integer> uniqList1 =  intList.stream()
                .distinct()
                .collect(Collectors.toList());
        System.out.println("Unique List using Declarative: "+uniqList1);
    }
}
=================================================================
Lambda:
=================================================================
--> Lambda is equivalent to function(method) without a name.
--> Lambda's are also called as Anonymous functions.
	-> Method parameters
	-> method body
	-> return type
--> Lambdas are not tied to any class like a regular method.
--> Lambda can also be assigned to variable and passed around.
syntax:
	() -> {}.
-----------------
Usages of Lambda:
-----------------
--> Lambda is mainly used to implement Functional Interfaces.
--> Functional Interfaces, which contains only 1 abstract method and any number of default and static methods are called functional interfaces.
	eg:
	@FunctionalInterface
	public interface Comparator<T> {
		int compare(T o1, T o2);
	}
	
	@FunctionalInterface
	public interface Runnable {
		
		public abstract void run();
	}

Eg: Lets code our first Lambda - Implement Runnable using Lambda:
-----------------------------------------------------------------
Old Style:
----------
public class OldRunnableImplementation {
	public staitc void main() {
		
		Thread thread = new Thread(new Runnable(){

			public void run() {
				System.out.println("Old Style");
			}
		};); 
		thread.start();
		//or
		Runnable runnable = new Runnable() {
			
			public void run() {
				System.out.println("Another Old Style");
			}
		};
		new Thread(runnable).start();
	}
	//java 8 lambda syntax
	
	Runnable runnable = () -> System.out.println("new style");
	new Thread(runnable).start();
	//or
	new Thread(() -> System.out.println("new Style")).start();
	
}
---------------------------------------
-> Implement Comparator interface using Lambda:
-----------------------------------------------
//Using old method:
-------------------
public class ComparatorInterfaceImpl {
	public static void main(String args[]) {
		
		Comparator<Integer> comp = new Comparator<Integer>() {
			public int compare(Integer i1,Integer i2) {
				return i1.compareTo(i2);
			}
		};	
		System.out.println("Result of Comparator: "+comp.compare(10,20));	
	
		// using lambda expression
	
		Comparator<Integer> comp = (i1,i2) -> i1.compareTo(i2);
	}
}
==================================================================
Lambda vs Functional Interfaces:
==================================================================
-> Functional Interfaces main purpose is, Code reusability, mainly we can reuse the same functional interface code across the project.
-> Functional interfaces avoid code duplicate. common functionality we can declare in top of the class and we can re-use in entire class. Or we can declare common code in utility code and re-use that utility class.
-> Lambda expression we can assign to a variable and reuse that variable just like normal variable, in entire class.
-> Functional interfaces exists in java since java 1.0
-> Any interface which contains exactly only one abstract method is called Functional Interface.
-> @FunctionalInterface introduced in java 1.8 and all the functional interfaces which annotated with @FunctionalInterface. This annotation is optional.
-> New FunctionalInterfaces introduced in java 1.8:
	-> Predicate, BiPredicate
	-> Function, BiFunction, UnaryOperator, BinaryOperator
	-> Consumer, BiConsumer
	-> Supplier
-> Consumer FunctionalInterface practicals:
-------------------------------------------
-> Available in java.util.function package
-> It is having 2 methods: 
	1) void accept(T t) -> abstract method
	2) andThen() -> default method
-> It accepts only 1 input value.
-> Eg: 1) public class ConsumerExample {
	public static void main(String args[]) {
		
		Consumer con = name -> System.out.println("name length: "+ name.length()); 

		con.accept("Raja");
	}
}
-> Eg: 2) 
	public static void printStudents() {
		
		Consumer conStudent = student -> System.out.println(student);
		List<Student> stuList = StudentDatabase.getAllStudentDetails();
		stuList.forEach(conStudent);
	}
-> Eg: 3)
	public static void printStudentNameAndActivities() {
		Consumer nameConsumer = s -> System.out.println(s.getName());
		Consumer activityConsumer = s-> System.out.println(s.getActivities());
		List<Student> stuList = StudentDatabase.getAllStudentDetails();
		stuList.forEach(nameConsumer.andThen(activityConsumer));// This is called consumer chain
	}
-> Eg: 4) // print list of students whose grade is >3
	public static void getDetails() {
		
		Consumer nameConsumer = s -> System.out.println(s.getName());
		Consumer activityConsumer = s-> System.out.println(s.getActivities());
		Consumer stCon = s -> System.out.println(s.getGrade()>3);
		List<Student> stList = StudentDatabase.getStudentDetails();
		
		stList.forEach(student -> {

			if(student.getGrade()>=3) {
				nameConsumer.andThen(activityConsumer).accept(student);
			} 
	
			//or

			if(student.getGrade()>=3 && student.getGPA()>=8) {
				nameConsumer.andThen(activityConsumer).accept(student);  --> here we can call andThen() method any number of times.
			} 

		};		
	}
-> Here lambda expression promotes the code reusability.
-> if(student.getGrade()>=3 && student.getGPA()>=8) -> here if we want reuse the condition like student.getGrade()>=3, then the code gets duplicated. to overcome this, we have Function Functional Interface.
------------------------------------------------------------------------------------------------
=> BiConsumer:
--------------
-> Available in java.util.function package
-> It is having 2 methods: 
	1) void accept(T t, U u) -> abstract method
	2) andThen() -> default method
-> It accepts 2 inputs.
-> Eg: 1)
public class BiConsumerExample {
	public static void main(String args[]) {
		
		BiConsumer<Integer,Integer> biCA = (i1,i2) -> System.out.println("Addition of 2 numbers is: "+(i1+i2));
		
		biCA.accept(10,20);
		BiConsumer<Integer,Integer> biCM = (i1,i2) -> System.out.println("Multiplication of 2 numbers is: "+(i1*i2));
		biCM.accept(10,20);
		
	//using andThen() method
		biCA.andThen(bicM).accept(10,20);
	}
}

public static void nameAndActivity() {
	List<Student> stList = StudentDataBase.getAllStudents();
	//using Consumer
	Consumer nameCon = s -> System.out.println(s.getName());
	Consumer acCon = s -> System.out.println(s.getActivity());
	//using BiConsumer
	BiConsumer<String, List<String> biCon = (name,activities) -> System.out.println(name+" : "+activites);
	stList.forEach(s -> biCon.accept(s.getName(),s.getActivites()));
}
-------------------------------------------------------------------
=> Predicate Functional Interface:
----------------------------------
-> Available in java.util.function package
-> It is having 2 methods: 
	1) boolean test(T t) -> abstract method
	2) and() -> default method 
	3) or() -> default method
	4) negate() -> default method -> will return reverse output. like, if actual result is true, then it will return false. if actual result is false, then it will return true. 
-> It accepts only 1 input.
-> Eg: 1) 
public class PredicateExample {
	static Predicate p = i -> i%2==0;
	static Predicate p2 = i-> i%5 ==0;
	public static void main(String args[]) {
		Predicate p = i -> i%2==0;
		//boolean result = p.test(10);
		//System.out.println("result: "+result);
		//or
		System.out.println(p.test(10)); // true
	}
	public static void predicateAnd() {
		
		boolean result = p.and(p2).test(5); // predicate chaining
		System.out.println(result); // false
	}
	public static void predicateOr() {
		System.out.println("result: "+p.or(p2).test(5)); // true
	
	}
	public static void predicateNegate() {
		System.out.println(p.or(p2).negate(9)); // true
	}
}
----------------------
Eg: Student Collection example using Predicate:
----------------------
public class StudentPredicateExample {
	
	static Predicate<Student> stPred = student -> student.getGrade()>3;
	static Predicate<Student> stPred1 = st -> st.getGpa()>3;
	static List<Student> stList = StudentDatabase.getAllStudents();
	public static void main(String args[]) {
		stList.forEach(student -> {
			if(stPred.test(student)) {

				System.out.println(student)
			}
		});
	}
	public void filterGpaGrade() {
	
		stList.forEach(st-> {
			//if(stPred.and(stPred1).test(st)) {
			//if(stPred.or(stPred1).test(st)) {
			if(stPred.negate(stPred1.test(st)) {
				System.out.println(st);
			}else { // this else part is only for negate method.
				System.out.println(st); 
			}
		});
	}
}
------------------------------------------------------
=> Combining Predicate and Consumer:
------------------------------------------------------
-> Eg: -> 
-> Above example we created static variable to re-use the functionality.
-> This time we are going with instance method with lambda expression. Because lambda expression behaves like instance method and static method aswell.
public class PredicateConsumerExample {

	public static void main(String args[]) {
		
	}
}











































==================================================================
Optional Class:
==================================================================
In Java, a commonly repeated exception is a NullPointerException. So to avoid NullPointerException, Java people introduced Optional Classes in the Java 8 version.
or
It is used to represent non-null value in java. It is used to avoid NullPointerException and avoid having too many null checks(unnecessary null checks).

Optional Object example:
------------------------
with out Optional class:
public class OptionalDemo {

    public static void main(String[] args) {
        String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
}
If Student class contains more properties, then each and every property we should check before accessing that property weather it is null or not?
----------------------------
with Optional Class:
-----------------------------
public class OptionalDemo {

    public static void main(String[] args) {
        /*String name = getStudentData();
        if(name!=null) {
            System.out.println("Student name length is: "+name.length());
        }else
            System.out.println("Name not found");*/

        Optional<String> nameOptional = getStudentNameUsingOptional();
        if(nameOptional.isPresent()) {
            System.out.println("Student name length is: " + nameOptional.get().length());
        }else
            System.out.println("Name not found");
    }
    public static String getStudentData() {

        //Student student = StudentData.getStudentData().get(0);
        Student student = null;
        if(student!=null) {
            return student.getName();
        }else
            return null;
    }
    public static Optional<String> getStudentNameUsingOptional() {

        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        if(studentOptional.isPresent()) {
            //return studentOptional.get().getName();
            return studentOptional.map(Student::getName);
        }
        return Optional.empty(); // will return Optional object with no value // will return NoSuchElementException
    }
}
Q) What is difference between if(obj!= null) vs if(obj.isPresent())?
-> Object will wrapped in the form of Optional and if object not contains any value also we can check with the help of optional class method isPresent() for data.
whereas !=null checking, we are directly checking the object, so if object not contains any value then we will get NullPointerException.

Q) Difference between return null; and return Optional.empty();?
-> return null, null can be accepted by any object like String or Student,
   Optional.empty() method can only return Optional object, by using optional object, we can call optional class methods.
------
Optional object creation -> Optional.of() vs  Optional.ofNullable(--) vs Optional.empty():
---------------------------------------------------------------------------
Optional.ofNullable(--):
if we pass any parameter to ofNullable() then it will return Optional<that Object>, if we are not passing any valid paratmer to ofNullable() method then it will return empty Optional object.
Optional.of():
if we pass any parameter to of() then it will return Optional<that Object>, if we are not passing any valid paratmer to of() method then it will return NullPointerException.
Optional.empty():
It is used to return the empty Optional object.

Eg:
--
ublic class OptionalOfEmptyOfNullable {
    public static void main(String[] args) {

        System.out.println("Optional class ofNullable() with Parameter: "+ofNullableWithParameter().get()); // Rohan
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter()); // Optional.emtpy
        //System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().get()); // NoSuchElementException
        System.out.println("Optional class ofNullable() without parameter: "+ofNullableWithoutParameter().isPresent()); // false
        System.out.println("==================================");
        System.out.println("Optional class of() with paramter: "+ofwithParameter().get()); // Rohan
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter()); // NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().get()); NullPointerException
        //System.out.println("Optional class of() with out paramter: "+ofwithoutParameter().isPresent()); // NullPointerException
        System.out.println("==================================");
        System.out.println("Optional class empty(): "+empty()); // Optional.empty
        //System.out.println("Optional class empty(): "+empty().get()); //NoSuchElementException
    }
    public static Optional<String> ofNullableWithParameter() {
        Optional<String> optionalOfNullable = Optional.ofNullable("Rohan");
        return optionalOfNullable;
    }
    public static Optional<String> ofNullableWithoutParameter() {
        Optional<String> optionalOfNullablewithNull = Optional.ofNullable(null);
        return optionalOfNullablewithNull;
    }

    public static Optional<String> ofwithParameter() {
        return Optional.of("Rohan");
    }
    public static Optional<String> ofwithoutParameter() {
        return Optional.of(null);
    }
    public static Optional<String> empty() {
        return Optional.empty();
    }
}
----------------------
orElse("") vs orElseGet(()->"") vs orElseThrow(()->new R.E()): -
----------------------
orElse() -> This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return value which we passed in orElse("") parameter.

orElseGet() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the value which we passed in orElseGet(()->"").

orElseThrow() -> This method will take input as supplier. This method we can call on Optional object. if Optional object having proper data then it will return data otherwise it will return the Exception which we passed in orElseThrow(()-> new R.E()).

eg:
---
public class OptionalOrElseExample {
    //orElse()
    public static String orElseOptional() {
        //Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<Student> studentOptional = Optional.ofNullable(null);
        return studentOptional.map(Student::getName).orElse("default value");
    }
    //orElseGet()
    public static String orElseGetOptional() {
        //Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stuOptional = Optional.ofNullable(null);
        return stuOptional.map(Student::getName).orElseGet(() -> "No data found");
    }
    //orElseThrow()
    public static String orElseThrowOptional() {
        //Optional<Student> stOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        Optional<Student> stOptional = Optional.ofNullable(null);
        return stOptional.map(Student::getName).orElseThrow(()->new RuntimeException("Invalid inputs"));
    }
    public static void main(String[] args) {
        String name = orElseOptional();
        //System.out.println("orElse with proper Output: "+name);
        System.out.println("orElse with out proper output: "+name);
        System.out.println("-----------------------");
        String name1 = orElseGetOptional();
        System.out.println("orElseGet() with proper output: "+name1);
       // System.out.println("orElseGet() with out proper output: "+name1);
        System.out.println("-----------------------");
        String name2 = orElseThrowOptional();
        System.out.println("orElseThrow() with proper output: "+name2);
    }

}
----------------------------------------------------------------------------
isPresent() vs ifPresent()
isPresent() -> This method will check optional object having data or not?. if optional obj having data then it will return true, else it will return false.
ifPresent() -> This method will take input as Consumer. This method also will check optional obj having data or not. if Optional obj having data then it will perform any other operation like other method call or some other class method call using optional obj value as input through Consumer. if Optional obj not having data then no action taken.
Eg:
public class OptionalPresentExample {
    public static void main(String[] args) {

       Optional<String> optional =  Optional.ofNullable("Hello");
       Optional<String> optionalNull =  Optional.ofNullable(null);
        //isPresent()
        System.out.println("is Optional object having data? "+optional.isPresent()); //true
        System.out.println("is Optional object having data? "+optionalNull.isPresent()); //false
        System.out.println("===============");
        //ifPresent()
        optional.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // output will print
        optionalNull.ifPresent(s-> System.out.println("if Optional obj having data then do another operation: "+s)); // no output
    }
}
--------------------------
map() vs flatMap() vs filter() with respect to Optional Class:-
--------------------------
filter(predicate) -> This method will take predicate as input. This filter method we can apply on Optional object. By using this filter(), we can filter the data from Optional object.
map(Function) -> This method will take Function as input. This map method we can apply on Optional object. By using this map(), we can transform the data from Optional object.
eg:
public class OptionalMapFlatMapFilterExample {
    //filter
    public static void filterOptional() {
        Optional<Student> studentOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        studentOptional.filter(s -> s.getGpa()>8)
                .ifPresent(st-> System.out.println(st));
    }
    //map
    public static void mapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(1));
        //stuOptional.map(Student::getName)
        //        .ifPresent(s -> System.out.println(s));
        if(stuOptional.isPresent()) {
            Optional<String> sOptonal = stuOptional.filter(s->s.getGpa()>7)
                    .map(s->s.getName());
            System.out.println(sOptonal.get());
        }
    }
//flatMap
public static void flatMapOptional() {
        Optional<Student> stuOptional = Optional.ofNullable(StudentData.getStudentData().get(0));
        Optional<String> bikeName = stuOptional.filter(s->s.getGpa()>9)
                .flatMap(Student::getBike)
                .map(Bike::getName);
        //System.out.println("Bike Name: "+bikeName.get());
        bikeName.ifPresent(s-> System.out.println("Bike name: "+s));
    }
    public static void main(String[] args) {
        filterOptional();
        mapOptional();
	flatMapOptional();
    }
}

=========================================
Default and Static methods in interfaces:
=========================================
Before java8, its very difficult to add new features in interfaces to existing project. Because implementation classes will be effected. So to resolve this issue, Java people intruduced Default and static method in interfaces in java8.
-> Default method having default method. But if developer not satisfied with default implementation, then developer can override the default method in the implementation class.
-> Static method having the implementation. but we can not override the static method in implementation class. but we can declare exact satic method signature in implementation class. but it is not overriding. it is method hiding. advatage with method hiding is, we can stop seeing the developers default static method implementation in interface.
-> Default methods can be overridden but static methods can not be overridden.
eg:
public class DefaultMethodExample {

    public static void main(String[] args) {
        //sort the names in alphabetical order

        List<String> nameList = Arrays.asList("Raja","Amar","Bunny","Sunny");

        //approach - 1 , before java 8
        Collections.sort(nameList);
        System.out.println("Using Collections.sort(): "+nameList);
        System.out.println("-----------------------------");
        //approach - 2, using List default method sort()
        //nameList.sort(Comparator.comparing(Function.identity()));
        //or
        nameList.sort(Comparator.naturalOrder());
        System.out.println(nameList);
        System.out.println("-----------------------------");
        //from java8
       List<String> sortedList = nameList.stream()
                .sorted((i1,i2)->i1.compareTo(i2))
                .collect(Collectors.toList());
        System.out.println(sortedList);
        System.out.println("----------------------");

        //to reverse the order

        nameList.sort(Comparator.reverseOrder());
        System.out.println("reverse order: "+nameList);
    }
}
List interface having default methods called - sort(), retainAll() and spliterator()
------------------------------------------------------------------------------------
Exploring sort() operations using Comparator interface:
-------------------------------------------------------
ex:1:

public class DefaultMethodsEx2 {
    static Consumer<Student> studentConsumer = student -> System.out.println(student);
    static Comparator<Student> gradeComparator = Comparator.comparing(Student::getGradeLevel);
    static Comparator<Student> nameComparator = Comparator.comparing(Student::getName);
    public static void sortByName(List<Student> stuList) {
        System.out.println("After sorting :::::");
        Comparator<Student> studentComparator = Comparator.comparing(Student::getName);
        stuList.sort(studentComparator);
        //stuList.forEach(System.out::println);
        //or
        stuList.forEach(studentConsumer);
    }
    public static void sortByGPA(List<Student> stuList) {
        System.out.println("Sort by GPA ::::");
        //Consumer<Student> stuConsumer = Comparator.comparing((st1,st2)->st1.);
        stuList.sort(Comparator.comparingDouble(Student::getGpa));
        stuList.forEach(studentConsumer);
    }
    public static void comparingComparator(List<Student> stdList) {
        System.out.println(":::::::::: Comparator Comparing :::::::");
        stdList.sort(gradeComparator.thenComparing(nameComparator));
        stdList.forEach(studentConsumer);
    }
    public static void main(String[] args) {
        System.out.println("Before Sorting ::::");
        List<Student> studentList = StudentData.getStudentData();
        //System.out.println(studentList);
        studentList.forEach(studentConsumer);

        sortByName(studentList);
        sortByGPA(studentList);
        comparingComparator(studentList);
    }
}
----------------------------------------------------
Handle null values while sorting using comparator:
----------------------------------------------------
eg:2:
public static void sortWithNullValues(List<Student> stList) {
        System.out.println("Sort with null values");
        Comparator<Student> stComp = Comparator.nullsFirst(nameComparator);
        stList.forEach(studentConsumer);
    }
-> nullsFirst() --> this method will print null values at first.
-> nullsLast() --> this method will print null values at last.
----------------------------------------------------
Create an interface with default and static methods:
----------------------------------------------------
public interface Multiplier {

    int mulitply(List<Integer> intList);

    default int size(List<Integer> iList) {
        System.out.println("Multiplier interface size()");
        return iList.size();
    }
    static boolean isEmpty(List<Integer> intList) {
        return intList==null && intList.size()==0;
    }
}

public class MultiplierImpl implements Multiplier{

    @Override
    public int mulitply(List<Integer> intList) {
        return intList.stream()
                .reduce(1,(a,b)->a*b);
    }
    public int size(List<Integer> iList) {
        System.out.println("MultiplierImpl class size()");
        return iList.size();
    }
}

public class MultiplierClient {

    public static void main(String[] args) {

        Multiplier multiplier = new MultiplierImpl();
        List<Integer> iList = Arrays.asList(1,3,5);
        System.out.println("Multipling result is: "+multiplier.mulitply(iList)); //15
        System.out.println("size is: "+multiplier.size(iList)); //MultiplierImpl class size()

        System.out.println("is the List empty: "+Multiplier.isEmpty(iList)); // false
    }
}
here size() will invoke from MultiplierImpl class because always it invoke from runtime object. 
-----------------------------------------------------------------------------------------------
Abstract class vs interface in java8:
------------------------------------------------------------------------------------------------
-> Abstract classes having instance variables but interfaces does not.
-> Java 8 supports multiple inheritance. ie before java 8, it is not possible. --> need to test weather it is supported or not?
eg:
public interface Interface1 {

    default void methodA() {
        System.out.println("Inside Method A "+Interface1.class);
    }
}
public interface Interface2 extends Interface1{
    default void methodB() {
        System.out.println("Inside Method B "+Interface2.class);
    }
    default void methodA() {
        System.out.println("Inside Method A "+Interface2.class);
    }
}
public interface Interface3 extends Interface2{
    default void methodC() {
        System.out.println("Inside Method C "+Interface3.class);
    }
}
public class Client123 implements Interface1,Interface2,Interface3{

   /* public void methodA() {
        System.out.println("Inside Method A "+Interface1.class);
    }*/
    public static void main(String[] args) {

        Client123 c = new Client123();
        c.methodA(); // result will print from child interface class Interface2. At runtime always will print child class methods in overridding.
        c.methodB();
        c.methodC();
    }
}
Note: Here we are inheriting multiple behaviours from multiple interfaces. This is called multiple inheritance.
-----------------------------------
Multiple inheritance issues resolve"
-----------------------------------
When ever we are implementing interfaces and that interfaces having same method with signature. then java will confuse. so to resolve that cases, we have to  override that method in our implementation class.
Eg:
public interface Interface1 {

    default void methodA(){
        System.out.println("Method A from "+Interface1.class);
    }
}
public interface Interface4 {

    default void methodA(){
        System.out.println("Method A from "+Interface4.class);
    }
}
public class Client14 implements Interface1,Interface4{

    public void methodA(){
        System.out.println("Method A from "+Client14.class);
    }

    public static void main(String[] args) {

        Client14 c14 = new Client14();
        c14.methodA(); //Method A from class org.learn.java8.defaults.Client14
    }
}
========================================================================================================================================================
New Date/Time APIs
========================================================================================================================================================
LocalDate, LocalTime and LocalDateTime class introduced in Java 8 as part of java.time pacakge. - new classes are created with the inspiration of Joda-Time library.
--> Present in java.time package
--> All these new libraries are immutable to promote functional programming.
--> Supproting class like Instant, Duration, Period and etc.
--> LocalDate: Used to represent the date.
--> LocalDate: Used to represent the time.
--> LocalDateTime: Used to represent the Data and time.
Eg: 
public class NewDataTimeExample {
    public static void main(String[] args) {
        //LocalDate
        LocalDate localDate = LocalDate.now();
        //LocalTime
        LocalTime localTime = LocalTime.now();
        //LocalDateTime
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("Local Date: "+localDate); // Local Date: 2024-04-08
        System.out.println("Local Time: "+localTime); // Local Time: 13:34:25.722924100
        System.out.println("Local Date and Time: "+localDateTime); // Local Date and Time: 2024-04-08T13:34:25.722924100
    }
Note: now() is overloaded method. i.e.
now()
now(Clock clock)
now(ZoneId zone)
--------------------------------------------------------------
LocalDate class Example:
-------------------------------------------
public class LocalDateExample {
    public static void main(String[] args) {

        LocalDate localDate = LocalDate.now();
        System.out.println(localDate); //2024-04-08
        LocalDate localDate2 = LocalDate.of(2024,06,14);
        System.out.println(localDate2);
        LocalDate localDate3 = LocalDate.ofYearDay(2022,360);
        System.out.println(localDate3);
        /*Get values from LocalDate*/
        System.out.println("getMonth(): "+localDate.getMonth()); // APRIL
        System.out.println("getMonthValue(): "+localDate.getMonthValue()); // 4
        System.out.println("getDayOfMonth(): "+localDate.getDayOfMonth()); // 8
        System.out.println("getDayOfWeek(): "+localDate.getDayOfWeek()); // MONDAY
        System.out.println("getDayOfYear(): "+localDate.getDayOfYear()); //99
        System.out.println("Day of month using get(): "+localDate.get(ChronoField.DAY_OF_MONTH)); // 8
    }
}
Note: get() method will take input as TemporalField interface as input. So ChronoField is an enum to implement TemporalField interface. So ChronoField enum having lot of constants to get the Date details.
-------------------------------------------------------------------------------------------
LocalDate - Modify LocalDate object values:
------------------------------------------------------------------------------
/*Modifying LocalDate object values*/
        System.out.println("Increase Date value by 2: "+localDate.plusDays(2)); // 2024-04-10
        System.out.println("Increase Month value by 2: "+localDate.plusMonths(2)); // 2024-06-08
        System.out.println("Decrease Month value by 3: "+localDate.minusMonths(3)); // 2024-01-08
        System.out.println("To change the Year to 2022: "+localDate.withYear(2022)); // 2022-04-08

        System.out.println("Change year with ChronoField: "+localDate.with(ChronoField.YEAR,2020)); // 2020-04-08
        System.out.println("First day of next month using with method TemporalAdjusters: "+localDate.with(TemporalAdjusters.firstDayOfMonth())); // 2024-04-01
	System.out.println("Change year with ChronoUnit: "+localDate.minus(1, ChronoUnit.YEARS)); // 2023-04-08
---------------------------------

/*Additional Support methods*/

System.out.println("2024 is leap year or not? "+localDate.isLeapYear()); // true
        //or
        System.out.println("is Leap year? "+LocalDate.ofYearDay(2021,30).isLeapYear()); // false
        //localDate = 2024-04-08
        //localDate1 = 2024-06-14
        System.out.println("is equal? "+localDate.isEqual(localDate1)); // false
        System.out.println("is before? "+localDate.isBefore(localDate1)); // true
        System.out.println("is after? "+localDate.isAfter(localDate1)); // false

        /*Unsupported*/
       // System.out.println("subtract minutes: "+localDate.minus(2,ChronoUnit.MINUTES)); // R.E: UnsupportedTemporalTypeException
        // We can not subtract minutes from LocalDate.

        System.out.println("is supported: "+localDate.isSupported(ChronoUnit.MINUTES)); // false
	System.out.println("is supported? : "+localDate.isSupported(ChronoUnit.YEARS)); // true
------------------------------------------------------------------------------
LocalTime:
---------------------------------------------------------------------------
public class LocalTimeExample {
    public static void main(String[] args) {
        LocalTime localTime = LocalTime.now();
        System.out.println("LocalTime: "+localTime);
        LocalTime localTime1 = LocalTime.of(18,45);
        System.out.println("localTime.of(hours,minutes): "+localTime1);
        LocalTime localtime2 = LocalTime.of(10,30,45);
        System.out.println("localTime.of(hours,minutes,sec) "+localtime2);
        LocalTime localtime3 = LocalTime.of(21,35,10,485);
        System.out.println("LocalTime.of(H,M,S,NS)"+localtime3);

        /*Getting time details from LocalTime object*/

        System.out.println("getHours(): "+localTime.getHour()); //17
        System.out.println("getMinutes(): "+localTime.getMinute()); // 53
        System.out.println("getHours() using ChronoField: "+localTime.get(ChronoField.CLOCK_HOUR_OF_DAY)); // 17
        System.out.println("getSeconds() using ChronoField: "+localTime.get(ChronoField.MINUTE_OF_DAY)); //1074
        System.out.println("getSeconds(): "+localTime.getSecond()); //43
        System.out.println("toSecondsOfDay(): "+localTime.toSecondOfDay()); // 64607 // represents whole time in Seconds for the day.

        /*Modify values in localtime object*/
        System.out.println("minus hours: "+ localTime.minusHours(3));
        System.out.println("minus hours: "+localTime.minus(3, ChronoUnit.HOURS));
        System.out.println("midnight: "+ localTime.with(LocalTime.MIDNIGHT));
        System.out.println("change hours: "+localTime.with(ChronoField.HOUR_OF_DAY,5)); // HOURS ALWAYS 5
        System.out.println("plus minutes: "+localTime.plusMinutes(5));
        System.out.println("withhour(): "+localTime.withHour(13)); // always hours are 13
    }
}
---------------------------------------------------------------------
LocalDateTime class: 
---------------------------------------------------------------------
of() is factory method

eg:
public class LocalDateTimeExample {
    public static void main(String[] args) {

        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("LocalDateTime: "+localDateTime); // 2024-04-11T12:00:58.432252800

        LocalDateTime ldt = LocalDateTime.of(LocalDate.now(), LocalTime.now());
        System.out.println("LocalDateTime.of() "+ldt); // 2024-04-11T12:00:58.432252800
        LocalDateTime ldt1 = LocalDateTime.of(2024,02,23,13,55,20,958);
        System.out.println("LocalDateTime.of(): "+ldt1); // 2024-02-23T13:55:20.000000958
        //getting date and time from LocalDateTime instance
        System.out.println("getting hours: "+localDateTime.getHour()); // 13
        System.out.println("getting minutes: "+localDateTime.getMinute()); // 11
        System.out.println("getting day: "+localDateTime.getDayOfMonth()); //15
        System.out.println("getting day: "+localDateTime.getDayOfWeek()); // MONDAY
        System.out.println("getting day: "+localDateTime.getDayOfYear()); // 106
        System.out.println("getting day using another way: "+localDateTime.get(ChronoField.DAY_OF_MONTH)); // 15
        //modifying LocalDateTime
        System.out.println("Plus Hours: "+localDateTime.plusHours(3));
        System.out.println("Minus Days: "+localDateTime.minusDays(5));
        //with() method is very useful to modify the LocalDateTime

        System.out.println("Change minutes: "+localDateTime.withMinute(10)); // minutes always 10
        System.out.println("Change month: "+localDateTime.withMonth(1)); // month always 1
        

    }
}
------------------------------
Converting LocalDate / LocalTime to LocalDateTime and viceversa
------------------------------
eg:
LocalDate localDate = LocalDate.of(2020,12,30);
        System.out.println("atTime(): "+localDate.atTime(16,55)); // 2020-12-30T16:55 // atTime() will return LocalDateTime class with given time.
        LocalTime localTime = LocalTime.of(18,25,10);
        System.out.println("atDate(): "+localTime.atDate(LocalDate.of(2021,10,25))); // 2021-10-25T18:25:10 // atDate() will return LocalDateTime class with given date.
        //getting LocalDate and LocalTime from LocalDateTime instance

        LocalDateTime ldt2 = localTime.atDate(LocalDate.of(2022,10,30));
        System.out.println("toLocalDate: "+ldt2.toLocalDate()); // 2022-10-30
        System.out.println("toLocalTime: "+ldt2.toLocalTime()); // 18:25:10
--------------------------------------------------------------------------------------
Comparing Dates using Period class:
--------------------------------------------------------------------------------------
-> Period is a date-based representation of time in Days, Months and Years and is part of the java.time package

-> Compatible with LocalDate.

-> It represents a Period of Time not just a specific date and time.
example:
-> Period period1 = Period.ofDays(10); // represents a Period of 10 Days. ofDays() method is factory method.
-> Period period2 = Period.ofYears(20); // represents a period of 20 years.

Period: use-case:
-----------------
-> Mainly used to calculate the difference between the two dates.
LocalDate localDate1 = LocalDate.of(2018,01,01);
LocalDate localDate2 = LocalDate.of(2018,01,31);
Period period = Period.between(localDate1,localDate2); // caluclates the difference between the two dates.
**** Period is compatible with LocalDate only.
-> Period class does not contain any LocalTime related methods.
eg:
public class ComparingDatesPeriodEx {
    public static void main(String[] args) {

        LocalDate localDate1 = LocalDate.of(2018,01,01);
        LocalDate localDate2 = LocalDate.of(2018,8,28);

        //Period period =  Period.between(localDate1,localDate2);
        Period period = localDate1.until(localDate2);
        /*until() method is part of LocalDate class.  until() will return Period as return type.*/
        //System.out.println(period); // P1M27D
        System.out.println("get Days: "+period.getDays()); // 27 // result is 28-1
        System.out.println("get months: "+period.getMonths()); // 7 // result is 8-1
        System.out.println("get years: "+period.getYears()); // 0 // 2018-2018

        // Creating period instance using of...() factory method
        Period period1 = Period.ofDays(10);
        System.out.println("period1.getDays(): "+period1.getDays());
        Period period2 = Period.ofMonths(22);
        System.out.println("period2.getMonths(): "+period2.getMonths());
        Period period3 = Period.ofYears(10);
        System.out.println("period3.getYears(): "+period3.getYears());
        Period period4 = Period.ofWeeks(35);
        System.out.println("period4.getWeeks(): "+period4.getDays()); // 245

        System.out.println("period3.getMonths(): "+period3.getMonths()); // 0 // this is not right ways to find total months
        System.out.println("period3.toTotalMonths(): "+period3.toTotalMonths()); // 120
        /*by using Period class also we can compare dates using between(). i.e. Period.between(...)*/

        Period period5 = Period.between(localDate1,localDate2);
        System.out.println("Period: "+period5.getDays()+":"+period5.getMonths()+":"+period5.getYears());
        //*** Period.between() is compatible with LocalDate only. it will not accept LocalTime
        //Period.between(LocalTime.now(),LocalTime.now().plusHours(24)); // will not accept
    }
}
-------------------------------------
Duration:
-------------------------------------
-> A time based representation of time in hours, minutes, seconds and nanoseconds.
-> Compatible with LocalTime and LocalDateTime.
-> Duration class does not contain any LocalDate related methods.
-> It represents duration of time not just a specific time.
eg:
Duration hours = Duration.ofHours(3); // it represents the duration of 3 hours.
Duration minutes = Duration.ofMinutes(3); // it represents the duration of 3 minutes.

Duration: Use-case
------------------
It can be used to calculate the difference between the time objects such as LocalTime and LocalDateTime..
Eg:
LocalTime localTime1 = LocalTime.of(7,20);
LocalTime localTime2 = LocalTime.of(8,20);
Duration duration = Duration.between(localTime1,localTime2);
Eg:
public class ComparingTimeDurationEx {
    public static void main(String[] args) {
        LocalTime localTime1 = LocalTime.of(7,20);
        LocalTime localTime2 = LocalTime.of(8,20);
        Duration duration = Duration.between(localTime1,localTime2);
        System.out.println("duration.toMinutes(): "+duration.toMinutes()); // PT1H
        //until() is taking 2 parameters, 1 is second localTime instance and 2nd parameter is to represent the output in which format
        long diff = localTime1.until(localTime2, ChronoUnit.MINUTES);
        System.out.println("localTime.until(): "+diff); // 60
        Duration duration1 = Duration.ofHours(3);
        System.out.println("duration1.toMinutes(): "+duration1.toMinutes());
        //let's try to pass date info to Duration class. let's see what will happen
        LocalDate localDate1 = LocalDate.now();
        LocalDate localDate2 = LocalDate.now().plusDays(5);
        //Duration duration2 = Duration.between(localDate1,localDate2); // R.E: UnsupportedTemporalTypeException
        
    }
}

***********
Finally: If we have a use-case like time related logic like find the difference between 2 times then use Duration. If Date related comparisions then use Period class. 

-------------------------------------------------------------------------
Instant:
------------------------------------------------------------------------
--> The above class like Duration or Period are represent in human readable format.
--> Instant represents the time in machine readable format.
eg:
Instant ins = Instant.now();
--> Represents the time in seconds from January 01,1970(EPOCH) to current time as a huge number.

eg:
public class InstantEx {
    public static void main(String[] args) {
        Instant ins = Instant.now();
        System.out.println("Instant: "+ins); // 2024-04-16T07:51:53.714039600Z // it will print in human-readable format.
        //getEpochSecond() method will print the time in seconds from 01 Jan 1970 to till date in seconds. each day seconds is 86400
        System.out.println(ins.getEpochSecond()); //1713254150
        System.out.println(Instant.ofEpochSecond(0)); // 1970-01-01T00:00:00Z
        Instant ins1 = Instant.now();
        Duration diff = Duration.between(ins,ins1);
        System.out.println("diff: "+diff.getNano()); // 10028700
    }
}
-----------------------------------------------
Time Zones:
-----------------------------------------------
-> LocalDate, LocalTime or LocalDateTime classes are for Local Time Zone represents.
-> Java8 introduced time zones classes to represents worldwide times.
-> ZonedDateTime,ZoneID, ZoneOffset etc.
--> ZonedDateTime - Represents the date/time with its time zone.
	eg:
	2018-07-18T08:04:14.541+05:30[Asia/Calcutta]
--> ZoneOffset -> +05:30
	--> it represents offset time from the UDC time.
--> ZoneId -> [Asia/Calcutta]
	--> it represents the zone that time belongs too.
Eg:
public class ZonedDateTimeExample {
    public static void main(String[] args) {
        ZonedDateTime zonedDateTime = ZonedDateTime.now();
        System.out.println("zonedDateTime: "+zonedDateTime); //2024-04-16T13:40:38.122378700+05:30[Asia/Calcutta]
        System.out.println("zone offset: "+zonedDateTime.getOffset()); // +05:30
        System.out.println("zone id: "+zonedDateTime.getZone()); // Asia/Calcutta
        //System.out.println("Supported Zone Ids: "+ ZoneId.getAvailableZoneIds()); // will print all the zones
        //or
        /*ZoneId.getAvailableZoneIds()
                .stream()
                .forEach(System.out::println);*/
        System.out.println("How many zones available? : "+ZoneId.getAvailableZoneIds().size()); // 603
        //USA supports different time zones like CST,EST,MST and PST.
        //how to get different time zone time details
        System.out.println("India IST  : "+ZonedDateTime.now(ZoneId.of("Asia/Calcutta")));
        System.out.println("Chicago CST: "+ZonedDateTime.now(ZoneId.of("America/Chicago")));
        System.out.println("Detroit EST: "+ZonedDateTime.now(ZoneId.of("America/Detroit")));
        System.out.println("LA PST     : "+ZonedDateTime.now(ZoneId.of("America/Los_Angeles")));
        System.out.println("Denver MST : "+ZonedDateTime.now(ZoneId.of("America/Denver")));
        //try with overloaded now(Clock clock)

        System.out.println("ZonedDataTime.now(Clock clock) : India IST: "+ZonedDateTime.now(Clock.system(ZoneId.of("Asia/Calcutta"))));
        //Time Zone using LocalDateTime.now(ZoneId). It will print only time. but not off set or zone id.
        LocalDateTime localDateTimeZoneId = LocalDateTime.now(ZoneId.of("America/Denver"));
        System.out.println("LocalDateTime.now(ZoneId): "+localDateTimeZoneId); // 2024-04-16T03:28:43.678499100
        //Time Zone using LocalDateTime.now(Clock)

        LocalDateTime localDateTimeClock = LocalDateTime.now(Clock.system(ZoneId.of("America/Denver")));
        System.out.println("LocalDateTime.now(Clock): "+localDateTimeClock);

        //using Instant class print Zone related information
        Instant instantClock = Instant.now(Clock.system(ZoneId.of("America/Denver")));
        System.out.println("Instant.now(Clock): "+instantClock);
        //or
        LocalDateTime localDateTimeInstant = LocalDateTime.ofInstant(Instant.now(),ZoneId.of("America/Denver"));
        System.out.println("LocalDateTimeInstant: "+localDateTimeInstant);
        //current system zoneId fetching
        LocalDateTime localDateTimeInstantSystemZoneId = LocalDateTime.ofInstant(Instant.now(),ZoneId.systemDefault());
        System.out.println("LocalDateTimeInstant current system zone: "+localDateTimeInstantSystemZoneId);
    }
}
--------------------------------------------------
Convert LocalDateTime to ZonedLocalDate and time:
--------------------------------------------------
 LocalDateTime localDateTime1 = LocalDateTime.now();
        System.out.println("localDateTime1: "+localDateTime1);
        //ZonedDateTime localDateTimetoZonedDateTime = localDateTime1.atZone(ZoneId.of("America/Denver")); // It will add zone id to localDateTime instance. here localdateTime instance having india time and zone id is "America/Denver". So while converting from localDateTime to ZonedDatetime must and should use appropriate zone id.
        ZonedDateTime localDateTimetoZonedDateTime = localDateTime1.atZone(ZoneId.of("Asia/Calcutta")); // now it will print localdatetime with asia zone. This is correct combination.
        System.out.println("LocalDateTime to ZonedDateTime = "+localDateTimetoZonedDateTime);
        //using Instance class conversion
        ZonedDateTime instantToZonedDateTime = Instant.now().atZone(ZoneId.of("America/Denver")); // This will print proper zone date and time.
        System.out.println("Instant to ZonedDateTime: "+instantToZonedDateTime);

        //to Add offSet details
        //OffsetDateTime zoneOffSet = localDateTime1.atOffset(ZoneOffset.ofHours(-6)); // This combination is wrong. Set the proper offSet to localDateTime1 instance. This will add only offSet but not zoneId
        OffsetDateTime zoneOffSet = localDateTime1.atOffset(ZoneOffset.ofHours(+5));
        System.out.println("set offSet: "+zoneOffSet);
-------------------------------------------------------------------------------------
Converting java.util.Date/java.sql.Date to LocalDate
-----------------------------------------------------------
public class DateToLocalDateExample {
    public static void main(String[] args) {

        /*java.util.Date to LocalDate conversion and vice versa*/
        Date dateUtil = new Date();
        System.out.println("Date from util package: "+dateUtil); // Wed Apr 17 14:18:05 IST 2024
        //conversion
        //explanation
        /*dateUtil.toInstant() will return Instant class. instant.atZone() will return ZonedDateTime. then we will call either toLocalDate() or toLocalTime() or toLocalDateTime() */
        LocalDate dateToLocalDate = dateUtil.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        System.out.println("Date to LocalDate: "+dateToLocalDate); // 2024-04-17

        // now reverse conversion like LocalDate to Date
        Instant instant = dateToLocalDate.atTime(LocalTime.now()).atZone(ZoneId.systemDefault()).toInstant();
        Date localDatetoDate = new Date().from(instant);
        System.out.println("LocalDate to Date of util package: "+localDatetoDate); // Wed Apr 17 14:52:10 IST 2024

        /*java.sqlDate to LocalDate conversion and vice versa*/

        //LocalDate to java.sql.Date conversion
        java.sql.Date dateSQL = java.sql.Date.valueOf(dateToLocalDate);
        System.out.println("LocalDate to java.sql.Date: "+ dateSQL); // 2024-04-17
        //java.sql.Date to LocalDate
        LocalDate sqlDateToLocalDate = dateSQL.toLocalDate();
        System.out.println("SQL Date to LocalDate: "+sqlDateToLocalDate); // 2024-04-17
    }
}
------------------------------------------------------------------------
DateTimeFormatter:
------------------------------------------------------------------------
--> Introduced in java 8 and part of the package java.time.format.
--> Used to parse and format the LocalDate, LocalTime and LocalDateTime.
***** --> Lower and upper case alphabets plays major role while formatting.
		eg: yyyy:MM:ss or YYYY:MM:SS --> both will print different formats. So please refer java api document.
Parse and format:
------------------
--> parse: Converting a String to a LocalDate or LocalTime or LocalDateTime.
--> format: Converting a LocalDate or LocalTime or LocalDateTime to String.

Formatting LocalDate:
---------------------
Eg:
public class FormattingLocalDateExample {

    public static void parseLocalDate() {
        String date = "2024-04-17";
        LocalDate parseDate = LocalDate.parse(date);
        System.out.println("String to LocalDate: "+parseDate);
        // 2nd way
        LocalDate parseDate1 = LocalDate.parse(date, DateTimeFormatter.ISO_LOCAL_DATE);
        System.out.println("String to LocalDate 2nd Way: "+parseDate1);
        // 3rd way
        String date1 = "20240417"; // yyyyMMdd
        LocalDate parseDate2 = LocalDate.parse(date1,DateTimeFormatter.BASIC_ISO_DATE);
        System.out.println("String to LocalDate 3rd way: "+parseDate2);

        /*Custom defined date format*/
        // in this case we have to build our own parse using DateTimeFormatter class
        String date2 = "2024|04|17";
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy|MM|dd");
        LocalDate customDateLocalDate = LocalDate.parse(date2,dateTimeFormatter);
        System.out.println("Custom date formatter: "+customDateLocalDate);

        String date3 = "2024*04*17";
        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern("yyyy*MM*dd");
        LocalDate customDateLocalDate1 = LocalDate.parse(date3,dateTimeFormatter1);
        System.out.println("Custom date formatter: "+customDateLocalDate1);
        /*
        * We should not use reserved key words like # in String of Date like "2024#04#17"
        * */

        /*String date4 = "2024#04#17";
        DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofPattern("yyyy#MM#dd");
        LocalDate customDateLocalDate2 = LocalDate.parse(date4,dateTimeFormatter1);
        System.out.println("Custom date formatter: "+customDateLocalDate2); //java.lang.IllegalArgumentException: Pattern includes reserved character: '#'*/
    }
    public static void formatLocalDate() {
        /*LocalDate to String conversion*/
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        LocalDate localDate = LocalDate.now();
        String localDateToString = localDate.format(dateTimeFormatter);
        System.out.println("LocalDate to String: "+localDateToString);
    }
    public static void main(String[] args) {
        parseLocalDate();
        formatLocalDate();
    }
}
--------------------------------------------------------
Formatting LocalTime:
--------------------------------------------------------
Eg:
public class FormattingLocalTimeExample {
    public static void parseTime() {

        /*Parse means convert from String to LocalTime*/
        String time = "18:30";
        LocalTime localTime = LocalTime.parse(time);
        System.out.println("default String to LocalTime: "+localTime); // 18:30

        LocalTime localTime1 = LocalTime.parse(time,DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.println("String to LocalTime: "+localTime1); // 18:30

        /*Custom defined formats*/

        String time1 = "18*30*50";
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("HH*mm*ss"); // hh represents 12 hours and HH represents 24 hours format. mm is for minutes and MM is for months. becarefull.
        LocalTime localTime2 = LocalTime.parse(time1,dateTimeFormatter);
        System.out.println("Custom String to LocalTime: "+localTime2);
    }
    public static void formatTime() {
        /*convert from LocalTime to String*/
        LocalTime localTime = LocalTime.now();
        String localTimeToString = localTime.toString();
        System.out.println("LocalTime to String: "+localTimeToString);
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("HH*mm*ss");
        String localTimeToString1 = localTime.format(dateTimeFormatter);
        System.out.println("LocalTime to String using DTF: "+localTimeToString1); // 18*48*36

        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern("HH|mm|ss");
        String localTimeToString2 = localTime.format(dateTimeFormatter1);
        System.out.println("LocalTime to String using DTF: "+localTimeToString2); // 18|50|35
    }
    public static void main(String[] args) {
        parseTime();
        formatTime();
    }
}
----------------------------------------------------------------
Format / parse LocalDateTime using DateTimeFormatter:
----------------------------------------------------------------
eg:
public class FormattingLocalDateTimeExample {
    public static void parseLocalDateTime(){
        /*converting String to LocalDateTime*/
        String dateTime = "2018-04-17T15:45:55";
        LocalDateTime localDateTime = LocalDateTime.parse(dateTime);
        System.out.println("String to LocalDateTime: "+localDateTime);
        LocalDateTime localDateTime1 = LocalDateTime.parse(dateTime, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        System.out.println("String to LocalDateTime using DTF: "+localDateTime1);

        /*Custom DateTimeFormatter*/

        String dateTime1 = "2018-04-17T15|45|55";
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH|mm|ss");
        LocalDateTime localDateTime2 =  LocalDateTime.parse(dateTime1,dateTimeFormatter);
        System.out.println("Custom date time formatter: "+localDateTime2); //2018-04-17T15:45:55

        String dateTime2 = "2018-04-17abcd15|45|55";
        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd'abcd'HH|mm|ss");
        LocalDateTime localDateTime3 = LocalDateTime.parse(dateTime2,dateTimeFormatter1);
        System.out.println("Custom date time formatter: "+localDateTime3); // 2018-04-17T15:45:55
    }
    public static void formatLocalDateTime(){
        /*converting LocalDateTime to String*/
        LocalDateTime localDateTime = LocalDateTime.now();
        String localDateTimeToString = localDateTime.toString();
        System.out.println("LocalDateTime to String using toString(): "+localDateTimeToString); // 2024-04-18T16:15:58.516047500
        //or
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'abc'HH|mm|ss");
        String localDateTimeToString1 = localDateTime.format(dateTimeFormatter);
        System.out.println("LocalDateTime to String using formatter:"+localDateTimeToString1); // 2024-04-18abc16|15|58
        //or
        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH|mm|ss");
        String localDateTimeToString2 = localDateTime.format(dateTimeFormatter1);
        System.out.println("LocalDateTime to String using formatter:"+localDateTimeToString2); // 2024-04-18T16|19|03
    }
    public static void main(String[] args) {
        parseLocalDateTime();
        formatLocalDateTime();
    }
}
=========================================================================================================
Parallel and Asynchronus Programming in Modern Java:
=========================================================================================================
--> fast paced environment
--> In Software Programming:
	--> Code that we write should execute faster
--> Goal of Asynchronous and Paralle Programming:
	--> Provide Techniques to improve the performance of the code.
---------------------------
Technology Advancements:
--------------------------
Hardware vs Software:
---------------------
Hardware level:
---------------
-> Devices or computers comes up with Mutliple cores
-> Developer needs to learn programming patterns to maximize the use of multiple cores.
-> Apply the parallel programming concepts
-> for this use Parallel Streams
-> best example Threads
----------------
Software:
----------------
-> MicroServices Archetecture style
-> Blocking I/O calls are commoin in Microservices Architecture. This also impact the latency and performace of the application.
-> Apply asynchronous programming concepts.
-> for this use CompletableFuture.
-> best for Functional style of Programming 

-----------------------------------------------------------------------------------
Concurrency vs parallelism:
------------------------------------------------
-> Concurrency is a concept where two or more task can run simultaneously
-> in Java, Concurrency is achieved using Threads.
	-> Are the tasks running in interleaved fashion?
		ans: if system having only single core then, that single core will handle all the threads.
	-> Are the tasks running simultaneously?
		ans: if system having multiple cores then each core will handle one thread. This means tasks are running simultaneously.

for Example: 
public class BasicMultithreading {
    private static String result="";
    private static void hello() throws InterruptedException{
        Thread.sleep(500);
        result = result.concat("Hello");
    }
    private static void world() throws InterruptedException{
        Thread.sleep(600);
        result = result.concat(" world");
    }

    public static void main(String[] args) throws InterruptedException {

        Thread helloThread = new Thread(()-> {
            try {
                hello();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        Thread worldThread = new Thread(()->{
            try {
                world();
            }catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        helloThread.start();
        worldThread.start();

        helloThread.join();
        worldThread.join();
        System.out.println("result is: "+result);
    }
}

issues:
Threads normally need to interact with one another.
	--> Race condition
	--> DeadLocal and more.
To handle these issues, we have several options:
	--> Synchronized Locks, Semaphores
	--> Reentrant Locks, Semaphores
	--> Concurrent Collections
	--> Conditional Objects and More..
---------------------------------------------------
Now lets talk about
Parallelism:
----------------------------------------------------
-> Parallelism is a concept in which tasks are literally going to run in parallel.
-> Parallelism involves these steps:
	-> Decomposing the tasks in to SubTasks(Forking)
	-> Execute the subtasks in sequential
	-> Joining the results of the tasks(join)
	---> Whole process is also called Fork/Join.
Parallelism was introduced in java 7.
Eg:
---
public class BasicParallelism {
    public static void main(String[] args) {
        //use-case transform to Uppercase
        //[Bob, Jill, Rick] -> [BOB,JILL,RICK]
        List<String> nameList = List.of("Bob","Jill","Rick");
        System.out.println("Name List: "+nameList);
        List<String> parallelList =nameList.parallelStream()    //nameList.stream()
                                                                //.parallel()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        System.out.println("Parallel list: "+parallelList);
    }
}
Note: ParallelStream is nothing but fork and join.
--------------------------------------------------
Finally Concurrency vs Parallelism:
-------------------------------------------
Concurrency:
-------------
-> Concurrency is a concept where two or more tasks can run in simultaneously.
-> Concurrency can be implemented in single or multiple cores
-> Concurrency is about correctly and efficiently controlling access to shared resources.
----------
Parallelism:
------------
-> Parallelism is a concept where two or more tasks are literally running in parallel.
-> Parallelism can only be implemented in a multi-core machine.
-> Parallelism is about using more resources to access the result faster.
---------------------------------------------------------------------------------
Threads and its limitations:
----------------------------------------------------------------------------------
--> Threads allowed the developers to write asynchronous style of code.
--> 














































